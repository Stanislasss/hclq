//  __ __  __  __
// /  /  \|  \|_
// \__\__/|__/|__

{//code

package queryast

import (
	"fmt"
	. "github.com/mattolenik/hclq/structs"
	"reflect"
)

type Query struct {
	Parts []*Expr
}

type Expr struct {
	Path   *Path
	FnCall *FunctionCall
	Expr   interface{}
}

type FunctionCall struct {
	Name   string
	Params interface{}
}

type Path struct {
	Crumbs []*Crumb
}

type Crumb struct {
	Value string
}

type CrumbSeparator struct{}

type PipeSeparator struct{}

type Whitespace struct{}
}//code

//  __  __                  __
// / _ |__) /\ |\/||\/| /\ |__)
// \__)| \ /--\|  ||  |/--\| \

QUERY <- _ exp:Expr _ EOF {
    return exp, nil
}

Expr <- first:(Path / Function) rest:SubExpr? {
    result := &Expr{Expr: rest}
    switch v := first.(type) {
    case *Path:
        result.Path = v
    case *FunctionCall:
        result.FnCall = v
    default:
        return nil, fmt.Errorf("unexpected type in Expr")
    }
    return result, nil
}

SubExpr <- PipeSeparator expr:Expr {
    return expr, nil
}

Function <- ident:Ident args:Params? {
    if args == nil {
        args = []interface{}{}
    }
    return &FunctionCall{Name: ident.(string), Params: args}, nil
}

Params <- '(' params:MultiParam? ')' {
    return params, nil
}

MultiParam <- first:SingleParam rest:SubMultiParam* {
    results := []interface{}{first}
    results = append(results, AsSlice(rest)...)
    return results, nil
}

SubMultiParam <- ',' val:SingleParam {
    return val, nil
}

SingleParam <- _ param:Ident _ {
    return param, nil
}

Crumb <- CrumbSeparator ident:Ident {
    return &Crumb{Value: ident.(string)}, nil
}

Path <- vals:Crumb+ {
    crumbs := []*Crumb{}
    for _, v := range AsSlice(vals) {
        crumb, ok := v.(*Crumb)
        if !ok {
            return nil, fmt.Errorf("invalid type, expected type *Crumb")
        }
        crumbs = append(crumbs, crumb)
    }
    return &Path{Crumbs: crumbs}, nil
}

Ident <- val:Char+ {
    return string(c.text), nil
}

Char "unicode char" <- [\x30-\x39\x41-\x7A\xA1-\u10FFFF]

CrumbSeparator <- '.' {
    return &CrumbSeparator{}, nil
}

PipeSeparator <- _ '|' _ {
    return &PipeSeparator{}, nil
}

_ "whitespace" <- [ \t\r\n]* {
    return &Whitespace{}, nil
}

EOF ← !.