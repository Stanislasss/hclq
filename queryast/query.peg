//  __ __  __  __
// /  /  \|  \|_
// \__\__/|__/|__

{//code

package queryast

import (
	"fmt"
	. "github.com/mattolenik/hclq/structs"
	"reflect"
)

type Query struct {
	Parts *Expr
}

type Expr struct {
	Node interface{}
	Next interface{}
}

type FunctionCall struct {
	Name   string
	Params interface{}
}

type Path struct {
	Crumbs []*Crumb
}

type Crumb struct {
	Value string
}
}//code

//  __  __                  __
// / _ |__) /\ |\/||\/| /\ |__)
// \__)| \ /--\|  ||  |/--\| \

QUERY <- _ exp:Expr _ EOF {
    return exp, nil
}

Expr <- first:SubExpr rest:NextExpr? {
    result := &Expr{Node: first, Next: rest}
    return result, nil
}

SubExpr <- val:(Path / Function) {
    return val, nil
}

NextExpr <- PipeSeparator expr:Expr {
    return expr, nil
}

Function <- ident:Ident args:Params? {
    if args == nil {
        args = []interface{}{}
    }
    return &FunctionCall{Name: ident.(string), Params: args}, nil
}

Params <- '(' params:MultiParam? ')' {
    return params, nil
}

MultiParam <- first:SingleParam rest:NextSingleParam* {
    results := []interface{}{first}
    results = append(results, AsSlice(rest)...)
    return results, nil
}

NextSingleParam <- ',' val:SingleParam {
    return val, nil
}

SingleParam <- _ param:Expr _ {
    return param, nil
}

Crumb <- CrumbSeparator ident:Ident {
    return &Crumb{Value: ident.(string)}, nil
}

Path <- vals:Crumb+ {
    crumbs := []*Crumb{}
    for _, v := range AsSlice(vals) {
        crumb, ok := v.(*Crumb)
        if !ok {
            return nil, fmt.Errorf("invalid type, expected type *Crumb")
        }
        crumbs = append(crumbs, crumb)
    }
    return &Path{Crumbs: crumbs}, nil
}

Ident <- val:Char+ {
    return string(c.text), nil
}

Char "unicode ident char" <- [\x30-\x39\x41-\x5A\x61-\x7A\xA1-\u10FFFF]

CrumbSeparator <- '.' {
    return nil, nil
}

PipeSeparator <- _ '|' _ {
    return nil, nil
}

_ "whitespace" <- [ \t\r\n]* {
    return nil, nil
}

EOF ← !.

