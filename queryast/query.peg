//  __ __  __  __
// /  /  \|  \|_
// \__\__/|__/|__

{//code

package queryast

import (
	"fmt"
	. "github.com/mattolenik/hclq/structs"
	"reflect"
)

type Query struct {
	Parts []*Expr
}

type Expr struct {
	Trail  *Trail
	FnCall *FunctionCall
	Expr   interface{}
}

var ExprType Expr

type FunctionCall struct {
	Name   string
	Params interface{}
}

type Trail struct {
	Crumbs []*Crumb
}

type Crumb struct {
	Value string
}

type CrumbSeparator struct{}

type PipeSeparator struct{}

type Whitespace struct{}
}//code

//  __  __                  __
// / _ |__) /\ |\/||\/| /\ |__)
// \__)| \ /--\|  ||  |/--\| \

QUERY <- _ exp:Expr _ EOF {
    return exp, nil
}

Expr <- first:(Trail / Function) rest:SubExpr? {
    result := &Expr{Expr: rest}
    switch v := first.(type) {
    case Trail:
    case *Trail:
        result.Trail = v
    case FunctionCall:
    case *FunctionCall:
        result.FnCall = v
    }
    return result, nil
}

SubExpr <- PipeSeparator expr:Expr {
    return expr, nil
}

Function <- ident:Ident args:Params? {
    if args == nil {
        args = []interface{}{}
    }
    return &FunctionCall{Name: ident.(string), Params: args}, nil
}

Params <- '(' params:MultiParam? ')' {
    return params, nil
}

MultiParam <- first:SingleParam rest:(',' SingleParam)* {
    results := []string{first.(string)}
    for _, v := range AsSlice(rest) {
        vs := AsSlice(v)
        results = append(results, vs[1].(string))
    }
    return results, nil
}

SingleParam <- _ param:Ident _ {
    return param, nil
}

Crumb <- CrumbSeparator ident:Ident {
    return &Crumb{Value: ident.(string)}, nil
}

Trail <- vals:Crumb+ {
    crumbs := []*Crumb{}
    for _, v := range AsSlice(vals) {
        crumbs = append(crumbs, v.(*Crumb))
    }
    return &Trail{Crumbs: crumbs}, nil
}

Ident <- val:Char+ {
    return string(c.text), nil
}

Char <- [\x30-\x39\x41-\x7A\xA1-\u10FFFF]

CrumbSeparator <- '.' {
    return &CrumbSeparator{}, nil
}

PipeSeparator <- _ '|' _ {
    return &PipeSeparator{}, nil
}

_ "whitespace" <- [ \t\r\n]* {
    return &Whitespace{}, nil
}

EOF ← !.