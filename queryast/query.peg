//  __ __  __  __
// /  /  \|  \|_
// \__\__/|__/|__

{//code

package queryast

import (
	"fmt"
)

type Query struct {
	Parts *Expr
}

type Expr struct {
	Node interface{}
	Next interface{}
}

type FunctionCall struct {
	Name   string
	Params interface{}
}

type Path struct {
	Crumbs []*Crumb
}

type Crumb struct {
	Key *Key
}

type EmptySelector struct {
}

type IndexSelector struct {
	Index int
}

type SplatSelector struct {
}

type MapSelector struct {
	Key string
}

type Key struct {
	Ident    string
	Selector interface{}
}
}//code

//  __  __                  __
// / _ |__) /\ |\/||\/| /\ |__)
// \__)| \ /--\|  ||  |/--\| \

QUERY <- _ exp:Expr _ EOF {
    return exp, nil
}

Expr <- first:SubExpr rest:NextExpr? {
    result := &Expr{Node: first, Next: rest}
    return result, nil
}

SubExpr <- val:(Path / Function) {
    return val, nil
}

NextExpr <- PipeSeparator expr:Expr {
    return expr, nil
}

Function <- ident:Ident args:Params? {
    if args == nil {
        args = []interface{}{}
    }
    return &FunctionCall{Name: ident.(string), Params: args}, nil
}

Params <- '(' params:MultiParam? ')' {
    return params, nil
}

MultiParam <- first:SingleParam rest:NextSingleParam* {
    results := []interface{}{first}
    results = append(results, rest.([]interface{})...)
    return results, nil
}

NextSingleParam <- ',' val:SingleParam {
    return val, nil
}

SingleParam <- _ param:Expr _ {
    return param, nil
}

Crumb <- CrumbSeparator key:Key {
    return &Crumb{Key: key.(*Key)}, nil
}

Key <- ident:Ident sel:Selector? {
    return &Key{Ident:ident.(string), Selector:sel}, nil
}

Selector <- '[' val:(SplatSelector / IndexSelector / MapSelector / EmptySelector )? ']' {
    return val, nil
}

SplatSelector <- '*' {
    return &SplatSelector{}, nil
}

IndexSelector <- val:Int {
    return &IndexSelector{Index: val.(int)}, nil
}

MapSelector <- val:Ident {
    return &MapSelector{Key: val.(string)}, nil
}

EmptySelector <- _ {
    return &EmptySelector{}, nil
}

Path <- vals:Crumb+ {
    crumbs := []*Crumb{}
    for _, v := range vals.([]interface{}) {
        crumb, ok := v.(*Crumb)
        if !ok {
            return nil, fmt.Errorf("invalid type, expected type *Crumb")
        }
        crumbs = append(crumbs, crumb)
    }
    return &Path{Crumbs: crumbs}, nil
}

Ident <- val:Char+ {
    return string(c.text), nil
}

Char "unicode ident char" <- [\x2D\x5F\x30-\x39\x41-\x5A\x61-\x7A\xA1-\u10FFFF]

Int <- '-'? DecimalDigit+ {
    return strconv.Atoi(string(c.text))
}

DecimalDigit <- [0-9]

CrumbSeparator <- '.' {
    return nil, nil
}

PipeSeparator <- _ '|' _ {
    return nil, nil
}

_ "whitespace" <- [ \t\r\n]* {
    return nil, nil
}

EOF ← !.